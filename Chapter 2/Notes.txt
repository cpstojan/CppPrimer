Chapter 2 Notes

Introduction to Chapter 2:
-C++ defines several primitive types (characters, integers, floating-point numbers, etc.)
-more importantly C++ allows for the definition of our own data types
-the standard library allows defines more complicated types that can be very powerful

2.1 Primitive Built-in Types:
arithmetic types - built-in types representing boolean values, character, integers, and floating-point numbers
-the void type has no associated values
-artihmetic types are divided into two categories 
	1) integral types - character and booolean
	2) floating-point types
-minimum size (actual size depends on machine)
	bool - boolean - NA
	char - character - 8 bits
	wchar_t - wide character - 16 bits
	char16_t - unicode character - 32 bits
	char32_t - unicode character - 32 bits
	short - short integer - 16 bits
	int - integer - 16 bits
	long - long integer - 32 bits
	long long - long integer 64 bits
	
-a float is a single-precision floating-point containing 6 siginificant digits
-a double is a double-precision floating-point containing 10 siginificant digits
-a long double is an extended-precision floating-point containing 10 significant digits
-most compilers provide more precision than the speciied minimum of significant digits
-a char is guaranteed to be big enough to hold numeric values corresponding to the characters in the machine's basic character set
	-always the same size as a single machine byte
-a wchar_t is guranteed to be large enough to hold any character in the machine's largest extended character set
-Unicode is a standard for representing characters used in essentially any natural language
-the type long long was introduced by the new standard
-the smallest chunk of addressable memory is referred to as a byte
-a word is a small number of bytes
-on most machines a byte contains 8 bits and a word is either 32 or 64 bits
-typically floats are represented in one word, doubles in two words, and long doubles in three or four words
-other than bool and the extended character types, the integral types may be signed or unsigned
signed - integer type that holds negative or positive values, including zero
unsigned - integer type that holds only values greater than or equal to zero
-int, short, long and long long are all signed (must explicitally define it unsigned)
-unsigned int may be abbreviated as unsigned
-there are three distinct basic character types char, signed char, and unsigned char
-although there are three types of char there are only two representations signed and unsigned
-plain char types uses one of the representations (dependent on the compiler)
-C++, like C, is designed to let programs get close to the hardware
-rules of thumb when selecting what type to use
	-use an unsigned type when you know that the values cannot be negative
	-use int over short, if the value is larger than guaranteed size of int use long long
	-avoid using char for artihmetic expressions as it may be signed or unsigned depending on machine
	-if you need a tiny integer, explicitly specify either signed char or unsigned char
	-use double for floating-point computations over float as it's more precise and size difference is negligible
	-precision offered by long double usually is unnecessary

-many types support the ability to convert objects of the given type to other, related types
-C++ often does automatic type conversion when given an object of one type when another was expected
-when we assign a non-bool arithmetic type to a bool object the resule is false if the value is 0 and true otherwise
-when we assign a bool to an arithmetic type the resule value is 1 if true the bool is true otherwise 0
-when we assign a floating-point value to an object of integral type, the value is truncated
-when we assign an integral value to a floating-point type the fractional part is 0
-when we assign an out-of-range value to an unsigned type the result is the remainder of the value modulo the number of values the taret type can hold
	-8-bit unsigned can hold values from 0 to 255 inclusive, modulo 256, -1 produces 255
-when we assign an out-of-range value to an object of signed type, the result is undefined
-undefined may crash or may produce a garbage value
-undefined errors may still compile but leave the code open to risk of crashing at any time
-implenetation defined behavior should also be avoided as it will make the program non-portable
-if using an int value and an unsigned the int value ordinarily is converted to unsigned for example
	unsigned u =10;
	int i = -42;
	std::cout << u + i << std::endl // prints 4294967264
-when using unsigned in for loops you must be careful as they will never be negative (wrap around) while loops may be easier
-it is best not to mix signed and unsigned values as they can produce surprising results
-when mixing signed and unsigned values the result is always converted to an unsigned

literl - a value such as a number, character, or string of characters. The value cannot change.
-every literal has a type
-integer literals that begin with 0 are interpreted as octal
-integer literals that begin with 0x or 0X are interpreted as hexadecimal
	20 /* decimal */ 024 /* octal */ 0x14 /* hexadecimal */
-the type of an integer literal depend on its value and notation
-by default decimal literals are signed, octal and hexadecimal can be either
-there are no literals of type short
-we can override the defaults by using a suffix
	
	Chracter and Character String Literals:
	Prefix		Meaning					Type
	u			Unicode 16 character	char16_t
	U			Unicode 32 character	char32_t
	L			wide character			wchar_t
	
	Integer Literals
	Suffix		Minimum Type
	u or U		unsigned
	l or L		long
	ll or LL	long long
	
	Floating-Point Literals
	Suffix		Type
	f or F		float
	l or L		long double
-although integer literals may be stored in signed types, the value of a decimal literal is never a negative nnumber
-the minus sign is not part of the literal, it is an operator that negates the value of its (literal) operand
-by default dloating-point literals have type double
-floating point literals can also include an exponent
-a string literal is an array of constant chars, it is one longer than expected due to the null character added to every string literal
-string literals that are separated by only spaces, tabs, or newlines are concatenated into a single literal
	Escape Sequences to print special characters
	\n	newline
	\v	vertical tab
	\\	backslash
	\r	carriage return
	\t	horizontal tab
	\b	backspace
	\?	question mark
	\f	formfeed
	\a	alert (bell)
	\"	double quote
	\'	single quote
-the escape sequence could also be \x followed by hexadecimal digits or \ followed by octal digits
-for octal digits proceeding an escape sequence only the first three are evaluated
-for hexadecimal digits proceeding an escape sequence all are evaluated
-when you write a long literal, use the uppercase L as the lowercase letter l looks like the digit 1
-true and false are literals of type bool
-nullptr is a pointer literal

2.2 Variables:
variable - a named object or reference to manipulate.  In C++, variables must be declared before they are used.
-each variable has a type
-a variable definition consists of a type specifier, a list of one or more variable names separated by commas, and a semicolon
-an object that is initialized gets the specified value at the moment it is created
-initialization and assignment are different operations in C++
-initialization is giving a variable a value when it is created, assignment obliterates an objects current value and replaces it
-there are many ways to initialize in C++ for example all are valid
	int units_solid = 0;
	int units_sold = {0};
	int units_sold{0};
	int units_sold(0);
list initialization - form of initialization that uses curly braces to enclose one or more initializers
-the compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information
	long double ld = 3.1415926536;
	int {1d}. b = {1d} // error: narrowing conversion required
	int c(1d), d= 1d; // ok: but value will be truncated
default initialized - how objects are initialized when no explicit initializer is given
					- class type objects are initialized dependent on the classes implementation
					- objects of built-in type defined at global scope are initialized to 0
					- objects of built-in type defined at local scope are unitialized
